# ë°ì´í„°ë² ì´ìŠ¤ í…Œì´ë¸” ìŠ¤í‚¤ë§ˆ ì„¤ê³„

## ğŸ“‹ ê°œìš”

í”„ë¡ íŠ¸ì—”ë“œì˜ TypeScript interfaceë¥¼ ê¸°ë°˜ìœ¼ë¡œ PostgreSQL ë°ì´í„°ë² ì´ìŠ¤ í…Œì´ë¸”ì„ ì„¤ê³„í–ˆìŠµë‹ˆë‹¤.

---

## ğŸ—„ï¸ í…Œì´ë¸” ëª©ë¡

### âœ… ì‹¤ì œ êµ¬í˜„ í…Œì´ë¸” (v1.0)

1. **users** - ì‚¬ìš©ì ì •ë³´
2. **transactions** - ê±°ë˜ ë‚´ì—­
3. **anomalies** - ì´ìƒ ê±°ë˜
4. **coupons** - ì¿ í°
5. **sessions** - ì„¸ì…˜ ê´€ë¦¬

### ğŸ“‹ ì¶”í›„ í™•ì¥ ì˜ˆì • (v2.0+)

6. **audit_logs** - ê°ì‚¬ ë¡œê·¸ (í˜„ì¬: íŒŒì¼/ì½˜ì†” ë¡œê·¸ ì‚¬ìš©)
7. **jwt_blacklist** - JWT ë¸”ë™ë¦¬ìŠ¤íŠ¸ (í˜„ì¬: ë¯¸ì‚¬ìš©)

---

## 1. users - ì‚¬ìš©ì í…Œì´ë¸”

### TypeScript Interface
```typescript
interface User {
  id: string;
  name: string;
  email: string;
  passwordHash: string;
  role: 'user' | 'admin';
  phoneNumber?: string;
  createdAt: string;
  updatedAt: string;
  lastLoginAt?: string;
  isActive: boolean;
}
```

### PostgreSQL DDL
```sql
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(100) NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    role VARCHAR(20) NOT NULL DEFAULT 'user' CHECK (role IN ('user', 'admin')),
    phone_number VARCHAR(20),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    last_login_at TIMESTAMP WITH TIME ZONE,
    is_active BOOLEAN DEFAULT TRUE,
    
    -- ì¸ë±ìŠ¤
    CONSTRAINT chk_email_format CHECK (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$')
);

-- ì¸ë±ìŠ¤ ìƒì„±
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_role ON users(role);
CREATE INDEX idx_users_created_at ON users(created_at DESC);

-- íŠ¸ë¦¬ê±° (updated_at ìë™ ì—…ë°ì´íŠ¸)
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_users_updated_at BEFORE UPDATE ON users
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
```

### SQLAlchemy ëª¨ë¸
```python
from sqlalchemy import Column, String, Boolean, DateTime, CheckConstraint
from sqlalchemy.dialects.postgresql import UUID
from datetime import datetime
import uuid

class User(Base):
    __tablename__ = "users"
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name = Column(String(100), nullable=False)
    email = Column(String(255), unique=True, nullable=False, index=True)
    password_hash = Column(String(255), nullable=False)
    role = Column(String(20), nullable=False, default='user', index=True)
    phone_number = Column(String(20))
    created_at = Column(DateTime(timezone=True), nullable=False, default=datetime.utcnow, index=True)
    updated_at = Column(DateTime(timezone=True), nullable=False, default=datetime.utcnow, onupdate=datetime.utcnow)
    last_login_at = Column(DateTime(timezone=True))
    is_active = Column(Boolean, default=True, nullable=False)
    
    __table_args__ = (
        CheckConstraint("role IN ('user', 'admin')", name='chk_user_role'),
    )
```

---

## 2. transactions - ê±°ë˜ ë‚´ì—­ í…Œì´ë¸”

### TypeScript Interface
```typescript
interface Transaction {
  id: string;
  userId: string;
  merchant: string;
  amount: number;
  category: string;
  transactionDate: string;
  paymentMethod: string;
  note?: string;
  isAnomaly?: boolean;
  createdAt: string;
  updatedAt: string;
}
```

### PostgreSQL DDL
```sql
CREATE TABLE transactions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    merchant VARCHAR(200) NOT NULL,
    amount DECIMAL(15, 2) NOT NULL CHECK (amount >= 0),
    category VARCHAR(50) NOT NULL,
    transaction_date TIMESTAMP WITH TIME ZONE NOT NULL,
    payment_method VARCHAR(50) NOT NULL,
    note TEXT,
    is_anomaly BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- ì¸ë±ìŠ¤ ìƒì„±
CREATE INDEX idx_transactions_user_id ON transactions(user_id);
CREATE INDEX idx_transactions_date ON transactions(transaction_date DESC);
CREATE INDEX idx_transactions_category ON transactions(category);
CREATE INDEX idx_transactions_merchant ON transactions(merchant);
CREATE INDEX idx_transactions_amount ON transactions(amount);
CREATE INDEX idx_transactions_is_anomaly ON transactions(is_anomaly);
CREATE INDEX idx_transactions_user_date ON transactions(user_id, transaction_date DESC);

-- ë³µí•© ì¸ë±ìŠ¤ (ì„±ëŠ¥ ìµœì í™”)
CREATE INDEX idx_transactions_user_category_date ON transactions(user_id, category, transaction_date DESC);

-- updated_at íŠ¸ë¦¬ê±°
CREATE TRIGGER update_transactions_updated_at BEFORE UPDATE ON transactions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
```

### SQLAlchemy ëª¨ë¸
```python
from sqlalchemy import Column, String, Numeric, Boolean, DateTime, Text, ForeignKey, CheckConstraint, Index
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
import uuid

class Transaction(Base):
    __tablename__ = "transactions"
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    user_id = Column(UUID(as_uuid=True), ForeignKey('users.id', ondelete='CASCADE'), nullable=False, index=True)
    merchant = Column(String(200), nullable=False, index=True)
    amount = Column(Numeric(15, 2), nullable=False)
    category = Column(String(50), nullable=False, index=True)
    transaction_date = Column(DateTime(timezone=True), nullable=False, index=True)
    payment_method = Column(String(50), nullable=False)
    note = Column(Text)
    is_anomaly = Column(Boolean, default=False, nullable=False, index=True)
    created_at = Column(DateTime(timezone=True), nullable=False, default=datetime.utcnow)
    updated_at = Column(DateTime(timezone=True), nullable=False, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # ê´€ê³„
    user = relationship("User", back_populates="transactions")
    
    __table_args__ = (
        CheckConstraint('amount >= 0', name='chk_amount_positive'),
        Index('idx_transactions_user_category_date', 'user_id', 'category', 'transaction_date'),
    )
```

---

## 3. anomalies - ì´ìƒ ê±°ë˜ í…Œì´ë¸”

### TypeScript Interface
```typescript
interface Anomaly {
  id: string;
  userId: string;
  userName: string;
  merchant: string;
  amount: number;
  category: string;
  transactionDate: string;
  riskLevel: 'ìœ„í—˜' | 'ê²½ê³ ' | 'ì£¼ì˜';
  riskScore: number; // 0-100
  reason: string;
  status: 'pending' | 'approved' | 'rejected';
  createdAt: string;
  updatedAt: string;
}
```

### PostgreSQL DDL
```sql
CREATE TYPE risk_level_enum AS ENUM ('ìœ„í—˜', 'ê²½ê³ ', 'ì£¼ì˜');
CREATE TYPE anomaly_status_enum AS ENUM ('pending', 'approved', 'rejected');

CREATE TABLE anomalies (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    user_name VARCHAR(100) NOT NULL,
    merchant VARCHAR(200) NOT NULL,
    amount DECIMAL(15, 2) NOT NULL CHECK (amount >= 0),
    category VARCHAR(50) NOT NULL,
    transaction_date TIMESTAMP WITH TIME ZONE NOT NULL,
    risk_level risk_level_enum NOT NULL,
    risk_score DECIMAL(5, 2) NOT NULL CHECK (risk_score >= 0 AND risk_score <= 100),
    reason TEXT NOT NULL,
    status anomaly_status_enum NOT NULL DEFAULT 'pending',
    admin_note TEXT,
    approved_by UUID REFERENCES users(id),
    approved_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- ì¸ë±ìŠ¤ ìƒì„±
CREATE INDEX idx_anomalies_user_id ON anomalies(user_id);
CREATE INDEX idx_anomalies_status ON anomalies(status);
CREATE INDEX idx_anomalies_risk_level ON anomalies(risk_level);
CREATE INDEX idx_anomalies_transaction_date ON anomalies(transaction_date DESC);
CREATE INDEX idx_anomalies_created_at ON anomalies(created_at DESC);
CREATE INDEX idx_anomalies_status_created ON anomalies(status, created_at DESC);

-- ì „ë¬¸ ê²€ìƒ‰ ì¸ë±ìŠ¤ (ê°€ë§¹ì , ì‚¬ìœ )
CREATE INDEX idx_anomalies_merchant_trgm ON anomalies USING gin(merchant gin_trgm_ops);
CREATE INDEX idx_anomalies_reason_trgm ON anomalies USING gin(reason gin_trgm_ops);

-- updated_at íŠ¸ë¦¬ê±°
CREATE TRIGGER update_anomalies_updated_at BEFORE UPDATE ON anomalies
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
```

### SQLAlchemy ëª¨ë¸
```python
from sqlalchemy import Column, String, Numeric, DateTime, Text, ForeignKey, Enum, CheckConstraint, Index
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
import enum

class RiskLevelEnum(enum.Enum):
    HIGH = "ìœ„í—˜"
    MEDIUM = "ê²½ê³ "
    LOW = "ì£¼ì˜"

class AnomalyStatusEnum(enum.Enum):
    PENDING = "pending"
    APPROVED = "approved"
    REJECTED = "rejected"

class Anomaly(Base):
    __tablename__ = "anomalies"
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    user_id = Column(UUID(as_uuid=True), ForeignKey('users.id', ondelete='CASCADE'), nullable=False, index=True)
    user_name = Column(String(100), nullable=False)
    merchant = Column(String(200), nullable=False)
    amount = Column(Numeric(15, 2), nullable=False)
    category = Column(String(50), nullable=False)
    transaction_date = Column(DateTime(timezone=True), nullable=False, index=True)
    risk_level = Column(Enum(RiskLevelEnum), nullable=False, index=True)
    risk_score = Column(Numeric(5, 2), nullable=False)
    reason = Column(Text, nullable=False)
    status = Column(Enum(AnomalyStatusEnum), nullable=False, default=AnomalyStatusEnum.PENDING, index=True)
    admin_note = Column(Text)
    approved_by = Column(UUID(as_uuid=True), ForeignKey('users.id'))
    approved_at = Column(DateTime(timezone=True))
    created_at = Column(DateTime(timezone=True), nullable=False, default=datetime.utcnow, index=True)
    updated_at = Column(DateTime(timezone=True), nullable=False, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # ê´€ê³„
    user = relationship("User", foreign_keys=[user_id], back_populates="anomalies")
    approver = relationship("User", foreign_keys=[approved_by])
    
    __table_args__ = (
        CheckConstraint('amount >= 0', name='chk_anomaly_amount_positive'),
        CheckConstraint('risk_score >= 0 AND risk_score <= 100', name='chk_risk_score_range'),
        Index('idx_anomalies_status_created', 'status', 'created_at'),
    )
```

---

## 4. coupons - ì¿ í° í…Œì´ë¸”

### TypeScript Interface
```typescript
interface Coupon {
  id: string;
  userId: string;
  merchant: string;
  category: string;
  discountAmount: number;
  minPurchase: number;
  expiresAt: string;
  usedAt?: string;
  status: 'available' | 'used' | 'expired';
  createdAt: string;
  updatedAt: string;
}
```

### PostgreSQL DDL
```sql
CREATE TYPE coupon_status_enum AS ENUM ('available', 'used', 'expired');

CREATE TABLE coupons (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    merchant VARCHAR(200) NOT NULL,
    category VARCHAR(50) NOT NULL,
    discount_amount DECIMAL(10, 2) NOT NULL CHECK (discount_amount > 0),
    min_purchase DECIMAL(10, 2) NOT NULL DEFAULT 0 CHECK (min_purchase >= 0),
    expires_at TIMESTAMP WITH TIME ZONE NOT NULL,
    used_at TIMESTAMP WITH TIME ZONE,
    status coupon_status_enum NOT NULL DEFAULT 'available',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- ì¸ë±ìŠ¤ ìƒì„±
CREATE INDEX idx_coupons_user_id ON coupons(user_id);
CREATE INDEX idx_coupons_status ON coupons(status);
CREATE INDEX idx_coupons_expires_at ON coupons(expires_at);
CREATE INDEX idx_coupons_category ON coupons(category);
CREATE INDEX idx_coupons_user_status ON coupons(user_id, status);

-- updated_at íŠ¸ë¦¬ê±°
CREATE TRIGGER update_coupons_updated_at BEFORE UPDATE ON coupons
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- ë§Œë£Œ ì¿ í° ìë™ ìƒíƒœ ë³€ê²½ í•¨ìˆ˜ (ì„ íƒì‚¬í•­)
CREATE OR REPLACE FUNCTION update_expired_coupons()
RETURNS void AS $$
BEGIN
    UPDATE coupons
    SET status = 'expired'
    WHERE status = 'available'
    AND expires_at < CURRENT_TIMESTAMP;
END;
$$ LANGUAGE plpgsql;
```

### SQLAlchemy ëª¨ë¸
```python
from sqlalchemy import Column, String, Numeric, DateTime, ForeignKey, Enum, CheckConstraint, Index
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
import enum

class CouponStatusEnum(enum.Enum):
    AVAILABLE = "available"
    USED = "used"
    EXPIRED = "expired"

class Coupon(Base):
    __tablename__ = "coupons"
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    user_id = Column(UUID(as_uuid=True), ForeignKey('users.id', ondelete='CASCADE'), nullable=False, index=True)
    merchant = Column(String(200), nullable=False)
    category = Column(String(50), nullable=False, index=True)
    discount_amount = Column(Numeric(10, 2), nullable=False)
    min_purchase = Column(Numeric(10, 2), nullable=False, default=0)
    expires_at = Column(DateTime(timezone=True), nullable=False, index=True)
    used_at = Column(DateTime(timezone=True))
    status = Column(Enum(CouponStatusEnum), nullable=False, default=CouponStatusEnum.AVAILABLE, index=True)
    created_at = Column(DateTime(timezone=True), nullable=False, default=datetime.utcnow)
    updated_at = Column(DateTime(timezone=True), nullable=False, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # ê´€ê³„
    user = relationship("User", back_populates="coupons")
    
    __table_args__ = (
        CheckConstraint('discount_amount > 0', name='chk_discount_positive'),
        CheckConstraint('min_purchase >= 0', name='chk_min_purchase_non_negative'),
        Index('idx_coupons_user_status', 'user_id', 'status'),
    )
```

---

## 5. audit_logs - ê°ì‚¬ ë¡œê·¸ í…Œì´ë¸”

### TypeScript Interface
```typescript
interface AuditLog {
  id: string;
  userId?: string;
  action: string;
  resource: string;
  resourceId?: string;
  ipAddress: string;
  userAgent?: string;
  requestData?: object;
  responseStatus?: number;
  createdAt: string;
}
```

### PostgreSQL DDL
```sql
CREATE TABLE audit_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE SET NULL,
    action VARCHAR(100) NOT NULL,
    resource VARCHAR(100) NOT NULL,
    resource_id VARCHAR(255),
    ip_address INET NOT NULL,
    user_agent TEXT,
    request_data JSONB,
    response_status INTEGER,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- ì¸ë±ìŠ¤ ìƒì„±
CREATE INDEX idx_audit_logs_user_id ON audit_logs(user_id);
CREATE INDEX idx_audit_logs_action ON audit_logs(action);
CREATE INDEX idx_audit_logs_resource ON audit_logs(resource);
CREATE INDEX idx_audit_logs_created_at ON audit_logs(created_at DESC);
CREATE INDEX idx_audit_logs_ip_address ON audit_logs(ip_address);

-- JSONB ì¸ë±ìŠ¤ (ë¹ ë¥¸ ê²€ìƒ‰)
CREATE INDEX idx_audit_logs_request_data ON audit_logs USING gin(request_data);

-- íŒŒí‹°ì…”ë‹ (ì„ íƒì‚¬í•­ - ëŒ€ìš©ëŸ‰ ë¡œê·¸ ì²˜ë¦¬)
-- CREATE TABLE audit_logs_y2025m12 PARTITION OF audit_logs
--     FOR VALUES FROM ('2025-12-01') TO ('2026-01-01');
```

### SQLAlchemy ëª¨ë¸
```python
from sqlalchemy import Column, String, Integer, DateTime, ForeignKey, Text
from sqlalchemy.dialects.postgresql import UUID, INET, JSONB
import uuid

class AuditLog(Base):
    __tablename__ = "audit_logs"
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    user_id = Column(UUID(as_uuid=True), ForeignKey('users.id', ondelete='SET NULL'), index=True)
    action = Column(String(100), nullable=False, index=True)
    resource = Column(String(100), nullable=False, index=True)
    resource_id = Column(String(255))
    ip_address = Column(INET, nullable=False, index=True)
    user_agent = Column(Text)
    request_data = Column(JSONB)
    response_status = Column(Integer)
    created_at = Column(DateTime(timezone=True), nullable=False, default=datetime.utcnow, index=True)
```

---

## 6. sessions - ì„¸ì…˜ ê´€ë¦¬ í…Œì´ë¸”

### PostgreSQL DDL
```sql
CREATE TABLE sessions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    token_hash VARCHAR(255) NOT NULL UNIQUE,
    expires_at TIMESTAMP WITH TIME ZONE NOT NULL,
    ip_address INET,
    user_agent TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    last_accessed_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- ì¸ë±ìŠ¤ ìƒì„±
CREATE INDEX idx_sessions_user_id ON sessions(user_id);
CREATE INDEX idx_sessions_token_hash ON sessions(token_hash);
CREATE INDEX idx_sessions_expires_at ON sessions(expires_at);

-- ë§Œë£Œëœ ì„¸ì…˜ ìë™ ì‚­ì œ í•¨ìˆ˜
CREATE OR REPLACE FUNCTION delete_expired_sessions()
RETURNS void AS $$
BEGIN
    DELETE FROM sessions
    WHERE expires_at < CURRENT_TIMESTAMP;
END;
$$ LANGUAGE plpgsql;
```

### SQLAlchemy ëª¨ë¸
```python
class Session(Base):
    __tablename__ = "sessions"
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    user_id = Column(UUID(as_uuid=True), ForeignKey('users.id', ondelete='CASCADE'), nullable=False, index=True)
    token_hash = Column(String(255), unique=True, nullable=False, index=True)
    expires_at = Column(DateTime(timezone=True), nullable=False, index=True)
    ip_address = Column(INET)
    user_agent = Column(Text)
    created_at = Column(DateTime(timezone=True), nullable=False, default=datetime.utcnow)
    last_accessed_at = Column(DateTime(timezone=True), nullable=False, default=datetime.utcnow, onupdate=datetime.utcnow)
```

---

## 7. jwt_blacklist - JWT ë¸”ë™ë¦¬ìŠ¤íŠ¸ í…Œì´ë¸”

### PostgreSQL DDL
```sql
CREATE TABLE jwt_blacklist (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    jti VARCHAR(255) NOT NULL UNIQUE,
    token_type VARCHAR(20) NOT NULL CHECK (token_type IN ('access', 'refresh')),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    expires_at TIMESTAMP WITH TIME ZONE NOT NULL,
    blacklisted_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- ì¸ë±ìŠ¤ ìƒì„±
CREATE INDEX idx_jwt_blacklist_jti ON jwt_blacklist(jti);
CREATE INDEX idx_jwt_blacklist_expires_at ON jwt_blacklist(expires_at);
CREATE INDEX idx_jwt_blacklist_user_id ON jwt_blacklist(user_id);

-- ë§Œë£Œëœ í† í° ìë™ ì‚­ì œ
CREATE OR REPLACE FUNCTION delete_expired_jwt_blacklist()
RETURNS void AS $$
BEGIN
    DELETE FROM jwt_blacklist
    WHERE expires_at < CURRENT_TIMESTAMP;
END;
$$ LANGUAGE plpgsql;
```

### SQLAlchemy ëª¨ë¸
```python
class JWTBlacklist(Base):
    __tablename__ = "jwt_blacklist"
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    jti = Column(String(255), unique=True, nullable=False, index=True)
    token_type = Column(String(20), nullable=False)
    user_id = Column(UUID(as_uuid=True), ForeignKey('users.id', ondelete='CASCADE'), index=True)
    expires_at = Column(DateTime(timezone=True), nullable=False, index=True)
    blacklisted_at = Column(DateTime(timezone=True), nullable=False, default=datetime.utcnow)
    
    __table_args__ = (
        CheckConstraint("token_type IN ('access', 'refresh')", name='chk_token_type'),
    )
```

---

## ğŸ“Š ê´€ê³„ë„ (ERD)

```
users (1) ----< (N) transactions
users (1) ----< (N) anomalies
users (1) ----< (N) coupons
users (1) ----< (N) sessions
users (1) ----< (N) audit_logs
users (1) ----< (N) jwt_blacklist
anomalies (N) >---- (1) users (approver)
```

---

## ğŸš€ ë§ˆì´ê·¸ë ˆì´ì…˜ ìŠ¤í¬ë¦½íŠ¸

### Alembic ì´ˆê¸° ë§ˆì´ê·¸ë ˆì´ì…˜
```bash
# Alembic ì´ˆê¸°í™”
alembic init alembic

# ë§ˆì´ê·¸ë ˆì´ì…˜ ìƒì„±
alembic revision --autogenerate -m "Initial schema"

# ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹¤í–‰
alembic upgrade head
```

### ì „ì²´ ìŠ¤í‚¤ë§ˆ ìƒì„± ìŠ¤í¬ë¦½íŠ¸
```sql
-- schema.sql
-- 1. íƒ€ì… ìƒì„±
CREATE TYPE risk_level_enum AS ENUM ('ìœ„í—˜', 'ê²½ê³ ', 'ì£¼ì˜');
CREATE TYPE anomaly_status_enum AS ENUM ('pending', 'approved', 'rejected');
CREATE TYPE coupon_status_enum AS ENUM ('available', 'used', 'expired');

-- 2. í™•ì¥ ê¸°ëŠ¥ í™œì„±í™”
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pg_trgm"; -- ì „ë¬¸ ê²€ìƒ‰ìš©

-- 3. í…Œì´ë¸” ìˆœì„œëŒ€ë¡œ ìƒì„±
-- users
-- transactions
-- anomalies
-- coupons
-- audit_logs
-- sessions
-- jwt_blacklist

-- 4. ì¸ë±ìŠ¤ ìƒì„±
-- ê° í…Œì´ë¸”ì˜ ì¸ë±ìŠ¤ ìƒì„±ë¬¸

-- 5. íŠ¸ë¦¬ê±° ìƒì„±
-- updated_at íŠ¸ë¦¬ê±° ë“±

-- 6. í•¨ìˆ˜ ìƒì„±
-- ë§Œë£Œ ì¿ í° ì²˜ë¦¬, ì„¸ì…˜ ì •ë¦¬ ë“±
```

---

## âš¡ ì„±ëŠ¥ ìµœì í™” íŒ

### 1. ì¸ë±ìŠ¤ ì „ëµ
```sql
-- ìì£¼ ì¡°íšŒë˜ëŠ” ì»¬ëŸ¼ì— ì¸ë±ìŠ¤
CREATE INDEX idx_transactions_user_date ON transactions(user_id, transaction_date DESC);

-- ë¶€ë¶„ ì¸ë±ìŠ¤ (ìƒíƒœë³„ í•„í„°ë§)
CREATE INDEX idx_anomalies_pending ON anomalies(created_at DESC) 
WHERE status = 'pending';

-- ì „ë¬¸ ê²€ìƒ‰ ì¸ë±ìŠ¤
CREATE INDEX idx_transactions_merchant_trgm ON transactions 
USING gin(merchant gin_trgm_ops);
```

### 2. íŒŒí‹°ì…”ë‹ (ëŒ€ìš©ëŸ‰ ë°ì´í„°)
```sql
-- transactions í…Œì´ë¸” ì›”ë³„ íŒŒí‹°ì…”ë‹
CREATE TABLE transactions (
    -- ì»¬ëŸ¼ ì •ì˜
) PARTITION BY RANGE (transaction_date);

CREATE TABLE transactions_y2025m12 PARTITION OF transactions
    FOR VALUES FROM ('2025-12-01') TO ('2026-01-01');
```

### 3. ì •ê¸° ìœ ì§€ë³´ìˆ˜ ì‘ì—…
```bash
# Cron ì‘ì—…ìœ¼ë¡œ ë“±ë¡
0 2 * * * psql -U postgres -d caffeine_db -c "SELECT delete_expired_sessions();"
0 2 * * * psql -U postgres -d caffeine_db -c "SELECT update_expired_coupons();"
0 3 * * * psql -U postgres -d caffeine_db -c "VACUUM ANALYZE;"
```

---

## ğŸ“ ë°ì´í„° ìƒ˜í”Œ (í…ŒìŠ¤íŠ¸ìš©)

### users
```sql
INSERT INTO users (name, email, password_hash, role) VALUES
('í™ê¸¸ë™', 'hong@example.com', '$2b$12$...', 'user'),
('ê´€ë¦¬ì', 'admin@example.com', '$2b$12$...', 'admin');
```

### transactions
```sql
INSERT INTO transactions (user_id, merchant, amount, category, transaction_date, payment_method) VALUES
((SELECT id FROM users WHERE email = 'hong@example.com'), 'ìŠ¤íƒ€ë²…ìŠ¤', 15000, 'ì‹ë¹„', '2025-12-03 09:30:00+09', 'ì‹ ìš©ì¹´ë“œ');
```

---

**ì‘ì„±ì¼**: 2025-12-03  
**ì‘ì„±ì**: AI Assistant  
**ë²„ì „**: 1.0.0
